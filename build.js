import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';
import { marked } from 'marked';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

function readFileContent(filepath) {
  return fs.readFileSync(path.join(__dirname, filepath), 'utf-8');
}

function base64EncodeAssets() {
  const assetsDir = path.join(__dirname, 'assets');
  const assets = {};

  if (fs.existsSync(assetsDir)) {
    const files = fs.readdirSync(assetsDir).filter(f => !f.endsWith('.md'));
    files.forEach(file => {
      const filepath = path.join(assetsDir, file);
      const content = fs.readFileSync(filepath);
      const base64 = content.toString('base64');
      const ext = path.extname(file).toLowerCase();
      let mimeType = 'application/octet-stream';

      if (ext === '.png') mimeType = 'image/png';
      else if (ext === '.jpg' || ext === '.jpeg') mimeType = 'image/jpeg';
      else if (ext === '.gif') mimeType = 'image/gif';
      else if (ext === '.svg') mimeType = 'image/svg+xml';

      assets[file] = { base64, mimeType };
    });
  }

  return assets;
}

function buildPortfolio() {
  const portfolioDir = path.join(__dirname, 'portfolio');
  const portfolioConfig = JSON.parse(fs.readFileSync(path.join(portfolioDir, 'portfolio.json'), 'utf-8'));
  const projects = [];

  portfolioConfig.order.forEach(filename => {
    const mdPath = path.join(portfolioDir, filename);
    if (fs.existsSync(mdPath)) {
      const markdown = fs.readFileSync(mdPath, 'utf-8');
      const html = marked(markdown);
      projects.push({
        filename,
        html,
        markdown
      });
    }
  });

  return { projects, metadata: portfolioConfig.metadata };
}

function loadConfig() {
  const configPath = path.join(__dirname, 'config', 'subdomains-exclude.json');
  return JSON.parse(fs.readFileSync(configPath, 'utf-8'));
}

function escapeForTemplate(str) {
  return str.replace(/\\/g, '\\\\').replace(/`/g, '\\`').replace(/\$/g, '\\$');
}

console.log('ðŸ”¨ Building devious.work...');

const mainHtml = readFileContent('src/templates/main.html');
const portfolioHtml = readFileContent('src/templates/portfolio.html');
const vaultHtml = readFileContent('src/templates/vault.html');
const xokHtml = readFileContent('src/templates/xok.html');
const mainCss = readFileContent('src/styles/main.css');
const portfolioCss = readFileContent('src/styles/portfolio.css');
const vaultCss = readFileContent('src/styles/vault.css');
const mainJs = readFileContent('src/scripts/main.js');
const portfolioJs = readFileContent('src/scripts/portfolio.js');
const vaultJs = readFileContent('src/scripts/vault.js');

const assets = base64EncodeAssets();
const portfolio = buildPortfolio();
const config = loadConfig();

const workerTemplate = `
// Auto-generated by build.js - Do not edit directly

const RATE_LIMIT_COOLDOWN = 60;

const ASSETS = ${JSON.stringify(assets, null, 2)};
const PORTFOLIO = ${JSON.stringify(portfolio, null, 2)};
const CONFIG = ${JSON.stringify(config, null, 2)};

const TEMPLATES = {
  main: \`${escapeForTemplate(mainHtml)}\`,
  portfolio: \`${escapeForTemplate(portfolioHtml)}\`,
  vault: \`${escapeForTemplate(vaultHtml)}\`,
  xok: \`${escapeForTemplate(xokHtml)}\`
};

const STYLES = {
  main: \`${escapeForTemplate(mainCss)}\`,
  portfolio: \`${escapeForTemplate(portfolioCss)}\`,
  vault: \`${escapeForTemplate(vaultCss)}\`
};

const SCRIPTS = {
  main: \`${escapeForTemplate(mainJs)}\`,
  portfolio: \`${escapeForTemplate(portfolioJs)}\`,
  vault: \`${escapeForTemplate(vaultJs)}\`
};

function injectContent(template, style, script, replacements = {}) {
  let html = template
    .replace('{{STYLE}}', style)
    .replace('{{SCRIPT}}', script);

  Object.keys(replacements).forEach(key => {
    html = html.replace(new RegExp(\`{{$\{key}}}\`, 'g'), replacements[key]);
  });

  return html;
}

export default {
  async fetch(request, env, ctx) {
    const url = new URL(request.url);
    const path = url.pathname;

    // API Routes
    if (path === '/api/messages') {
      if (request.method === 'GET') return handleGetMessages(env);
      if (request.method === 'POST') return handlePostMessage(request, env);
      return new Response('Method Not Allowed', { status: 405 });
    }

    if (path === '/api/subdomains') {
      return handleGetSubdomains(env);
    }

    // Easter Egg Routes
    if (path === '/xok' || path === '/xok/') {
      const xokAsset = ASSETS['xok.png'];
      const html = injectContent(
        TEMPLATES.xok,
        '',
        '',
        {
          XOK_IMAGE: xokAsset ? \`data:$\{xokAsset.mimeType};base64,$\{xokAsset.base64}\` : ''
        }
      );
      return new Response(html, { headers: { 'Content-Type': 'text/html;charset=UTF-8' } });
    }

    if (path === '/vault' || path === '/vault/') {
      const html = injectContent(TEMPLATES.vault, STYLES.vault, SCRIPTS.vault);
      return new Response(html, { headers: { 'Content-Type': 'text/html;charset=UTF-8' } });
    }

    // Portfolio Route
    if (path === '/portfolio' || path === '/portfolio/') {
      let portfolioContent = '';
      PORTFOLIO.projects.forEach(project => {
        portfolioContent += \`<div class="portfolio-entry">$\{project.html}</div>\`;
      });

      const html = injectContent(
        TEMPLATES.portfolio,
        STYLES.portfolio,
        SCRIPTS.portfolio,
        { PORTFOLIO_CONTENT: portfolioContent }
      );
      return new Response(html, { headers: { 'Content-Type': 'text/html;charset=UTF-8' } });
    }

    // Favicon
    if (path === '/favicon.ico') {
      return new Response(null, { status: 204 });
    }

    // Main Page
    const html = injectContent(TEMPLATES.main, STYLES.main, SCRIPTS.main);
    return new Response(html, { headers: { 'Content-Type': 'text/html;charset=UTF-8' } });
  }
};

async function handleGetMessages(env) {
  try {
    const { keys } = await env.GUESTBOOK_LOGS.list();
    keys.sort((a, b) => b.name.localeCompare(a.name));
    const promises = keys.map(key => env.GUESTBOOK_LOGS.get(key.name, { type: 'json' }));
    const allMessages = await Promise.all(promises);
    return new Response(JSON.stringify(allMessages), {
      headers: { 'Content-Type': 'application/json' }
    });
  } catch (e) {
    console.error(e);
    return new Response('Error fetching messages', { status: 500 });
  }
}

async function handlePostMessage(request, env) {
  const ip = request.headers.get('CF-Connecting-IP') || 'unknown';
  const lastPostTimestamp = await env.RATE_LIMITER.get(ip);

  if (lastPostTimestamp) {
    const timeSinceLastPost = (Date.now() - parseInt(lastPostTimestamp, 10)) / 1000;
    if (timeSinceLastPost < RATE_LIMIT_COOLDOWN) {
      return new Response(
        \`Rate limit exceeded. Please wait $\{Math.ceil(RATE_LIMIT_COOLDOWN - timeSinceLastPost)} more seconds.\`,
        { status: 429 }
      );
    }
  }

  try {
    const body = await request.json();
    if (!body.name || !body.message || body.name.trim().length === 0 || body.message.trim().length === 0) {
      return new Response('Name and message cannot be empty.', { status: 400 });
    }

    const timestamp = new Date().toISOString();
    const key = \`message:$\{timestamp}:$\{Math.random().toString(36).substr(2, 9)}\`;
    const value = {
      name: body.name.trim(),
      message: body.message.trim(),
      timestamp
    };

    await env.GUESTBOOK_LOGS.put(key, JSON.stringify(value));
    await env.RATE_LIMITER.put(ip, Date.now().toString(), { expirationTtl: RATE_LIMIT_COOLDOWN });

    return new Response('Message posted successfully', { status: 201 });
  } catch (e) {
    console.error(e);
    return new Response('Error posting message', { status: 500 });
  }
}

async function handleGetSubdomains(env) {
  try {
    // Return manual subdomains from config for now
    // When API token is available, this will autodiscover
    const subdomains = CONFIG.manualSubdomains || [];
    return new Response(JSON.stringify(subdomains), {
      headers: { 'Content-Type': 'application/json' }
    });
  } catch (e) {
    console.error(e);
    return new Response('Error fetching subdomains', { status: 500 });
  }
}
`;

fs.writeFileSync(path.join(__dirname, 'worker.js'), workerTemplate);
console.log('âœ… Build complete! worker.js generated.');
